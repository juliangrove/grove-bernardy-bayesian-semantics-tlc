{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ViewPatterns #-}

module TLC.Terms where

import Data.Functor.Identity
import Prelude hiding (Monad(..))

data Type = E | T | R | U | Œì
          | Type :-> Type
          | Unit
          | Type :√ó Type

data (Œ± :: Type) ‚àà (Œ≥ :: Type) where
  Get :: Œ± ‚àà (Œ≥ √ó Œ±)
  Weaken :: Œ± ‚àà Œ≥ -> Œ± ‚àà (Œ≥ √ó Œ≤)
deriving instance Show (Œ± ‚àà Œ≥)

type Œ± √ó Œ≤ = Œ± ':√ó Œ≤
type Œ± ‚ü∂ Œ≤ = Œ± ':-> Œ≤

(‚âê) :: Equality Œ± => Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ R
m ‚âê n = App (App (Con (Rl EqGen)) m) n

class Equality Œ± where
  equals :: (Œ≥ ‚ä¢ Œ±) -> (Œ≥ ‚ä¢ Œ±) -> Œ≥ ‚ä¢ R
instance Equality E where
  equals (Con (Special Vlad)) (Con (Special Vlad)) = Con $ Rl $ Incl 1
instance Equality R where
  equals (Con (Rl (Incl x))) (Con (Rl (Incl y))) = case x == y of
                                                     True -> Con $ Rl $ Incl 1
                                                     False -> Con $ Rl $ Incl 0
  equals (Con (Special Theta)) (Con (Special Theta)) = Con $ Rl $ Incl 1
  equals x y = App (App (Con (Rl EqRl)) x) y 
instance Equality U where
  equals (Con (Special (Utt i))) (Con (Special (Utt j))) = case i == j of
                             True -> Con $ Rl $ Incl 1
                             False -> Con $ Rl $ Incl 0
instance Equality Unit where
  equals TT TT = Con $ Rl $ Incl 1
instance (Equality Œ±, Equality Œ≤) => Equality (Œ± √ó Œ≤) where
  equals (Pair m n) (Pair m' n')
    = App (App (Con $ Rl $ Mult) (equals m m')) (equals n n')
  equals m n = App (App (Con $ Rl $ EqGen) m) n
instance Equality (E ‚ü∂ R) where
  equals (Con (Special Height)) (Con (Special Height)) = Con $ Rl $ Incl 1
  equals (Lam m) (Lam n) | isConstant 0 m && isConstant 0 n
    = case equals m n of
        Con (Rl (Incl 1)) -> Con $ Rl $ Incl 1
        Con (Rl (Incl 0)) -> Con $ Rl $ Incl 0
        App (App (Con (Rl EqRl)) (Var (Weaken i))) (Var (Weaken j))
          -> App (App (Con (Rl EqRl)) (Var i)) (Var j)
instance Equality (E ‚ü∂ T) where
  equals (Con (Special Human)) (Con (Special Human)) = Con $ Rl $ Incl 1
instance Equality (R ‚ü∂ (R ‚ü∂ T)) where
  equals (Con (Special GTE)) (Con (Special GTE)) = Con $ Rl $ Incl 1 
instance Equality Œì where
  equals (Con (Special Empty)) (Con (Special Empty)) = Con $ Rl $ Incl 1
instance Equality (E ‚ü∂ (Œì ‚ü∂ Œì)) where
  equals (Con (Special Upd)) (Con (Special Upd)) = Con $ Rl $ Incl 1
instance Equality (Œì ‚ü∂ E) where
  equals (Con (Special Sel)) (Con (Special Sel)) = Con $ Rl $ Incl 1

subEq :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
subEq (App (App (Con (Rl EqGen)) m) n) = equals m n
subEq (Var i) = Var i
subEq (Con c) = Con c
subEq (App m n) = App (subEq m) (subEq n)
subEq (Lam m) = Lam $ subEq m
subEq (Fst m) = Fst $ subEq m
subEq (Snd m) = Snd $ subEq m
subEq TT = TT
subEq (Pair m n) = Pair (subEq m) (subEq n)

reduce1step :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
reduce1step (App (App (Con (Rl Mult)) (Con (Rl (Incl 1)))) n) = reduce1step n
reduce1step (App (App (Con (Rl Mult)) m) (Con (Rl (Incl 1)))) = reduce1step m
reduce1step (Var i) = Var i
reduce1step (Con c) = Con c
reduce1step (App m n) = App (reduce1step m) (reduce1step n)
reduce1step (Lam m) = Lam $ reduce1step m
reduce1step (Fst m) = Fst $ reduce1step m
reduce1step (Snd m) = Snd $ reduce1step m
reduce1step TT = TT
reduce1step (Pair m n) = Pair (reduce1step m) (reduce1step n)

canReduce :: Œ≥ ‚ä¢ Œ± -> Bool
canReduce (App (Con (Rl Mult)) (Con (Rl (Incl 1)))) = True
canReduce (App (App (Con (Rl Mult)) x) (Con (Rl (Incl 1)))) = True
canReduce (Var i) = False
canReduce (Con c) = False
canReduce (App m n) = canReduce m || canReduce n
canReduce (Lam m) = canReduce m
canReduce (Fst m) = canReduce m
canReduce (Snd m) = canReduce m
canReduce TT = False
canReduce (Pair m n) = canReduce m || canReduce n

reduce1s :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
reduce1s m = if canReduce m then reduce1s (reduce1step m) else m

clean :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
clean = reduce1s . subEq

isConstant :: Int -> Œ≥ ‚ä¢ Œ± -> Bool
isConstant i (Var Get) = i < 0
isConstant i (Var (Weaken j)) = isConstant (i - 1) (Var j)
isConstant i (Con c) = True
isConstant i (App m n) = isConstant i m && isConstant i n
isConstant i (Lam m) = isConstant (i + 1) m
isConstant i (Fst m) = isConstant i m
isConstant i (Snd m) = isConstant i m
isConstant i TT = True
isConstant i (Pair m n) = isConstant i m && isConstant i n

data Logical Œ± where
  Tru :: Logical T
  Fal :: Logical T
  And :: Logical (T ‚ü∂ (T ‚ü∂ T))
  Or :: Logical (T ‚ü∂ (T ‚ü∂ T))
  Imp :: Logical (T ‚ü∂ (T ‚ü∂ T))
  Forall :: Logical ((Œ± ‚ü∂ T) ‚ü∂ T)
  Exists :: Logical ((Œ± ‚ü∂ T) ‚ü∂ T)
  Equals :: Logical (Œ± ‚ü∂ (Œ± ‚ü∂ T))

instance Show (Logical Œ±) where
  show Tru = "‚ä§"
  show Fal = "‚ä•"
  show And = "(‚àß)"
  show Or = "(‚à®)"
  show Imp = "(‚Üí)"
  show Forall = "‚àÄ"
  show Exists = "‚àÉ"
  show Equals = "(=)"
  
data Rl Œ± where
  Incl :: Double -> Rl R
  Indi :: Rl (T ‚ü∂ R)
  Mult :: Rl (R ‚ü∂ (R ‚ü∂ R))
  Divi :: Rl (R ‚ü∂ (R ‚ü∂ R))
  Nml :: Rl ((R √ó R) ‚ü∂ ((R ‚ü∂ R) ‚ü∂ R))
  Uni :: Rl ((R √ó R) ‚ü∂ ((R ‚ü∂ R) ‚ü∂ R))
  EqGen :: Equality Œ± => Rl (Œ± ‚ü∂ (Œ± ‚ü∂ R))
  EqRl :: Rl (R ‚ü∂ (R ‚ü∂ R))

instance Show (Rl Œ±) where
  show (Incl x) = show x
  show Indi = "ùüô"
  show Mult = "(*)"
  show Divi = "(/)"
  show Nml = "Normal"
  show Uni = "Uniform"
  show EqGen = "(‚âê)"
  show EqRl = "(‚âê)"

data Special Œ± where
  Utt :: Int -> Special U
  Vlad :: Special E
  Height :: Special (E ‚ü∂ R)
  Human :: Special (E ‚ü∂ T)
  Theta :: Special R
  GTE :: Special (R ‚ü∂ (R ‚ü∂ T))
  Empty :: Special Œì
  Upd :: Special (E ‚ü∂ (Œì ‚ü∂ Œì))
  Sel :: Special (Œì ‚ü∂ E)

instance Show (Special Œ±) where
  show (Utt i) = "U" ++ show i
  show Vlad = "v"
  show Height = "height"
  show Human = "human"
  show Theta = "Œ∏"
  show GTE = "(‚â•)"
  show Empty = "Œµ"
  show Upd = "(‚à∑)"
  show Sel = "sel"

data Con Œ± where
  Logical :: Logical Œ± -> Con Œ±
  Rl :: Rl Œ± -> Con Œ±
  Special :: Special Œ± -> Con Œ±

instance Show (Con Œ±) where
  show (Logical c) = show c
  show (Rl c) = show c
  show (Special c) = show c

-- Well-typed terms.
data Œ≥ ‚ä¢ Œ± where
  Var :: Œ± ‚àà Œ≥ -> Œ≥ ‚ä¢ Œ±
  Con :: Con Œ± -> Œ≥ ‚ä¢ Œ±
  App :: Œ≥ ‚ä¢ (Œ± ‚ü∂ Œ≤) -> Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ≤
  Lam :: (Œ≥ √ó Œ±) ‚ä¢ Œ≤ -> Œ≥ ‚ä¢ (Œ± ‚ü∂ Œ≤)
  Fst :: Œ≥ ‚ä¢ (Œ± √ó Œ≤) -> Œ≥ ‚ä¢ Œ±
  Snd :: Œ≥ ‚ä¢ (Œ± √ó Œ≤) -> Œ≥ ‚ä¢ Œ≤
  TT :: Œ≥ ‚ä¢ Unit
  Pair :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ≤ -> Œ≥ ‚ä¢ (Œ± √ó Œ≤)

data Neutral Œ≥ Œ± where
  NeuVar :: Œ± ‚àà Œ≥ -> Neutral Œ≥ Œ±
  NeuCon :: Con Œ± -> Neutral Œ≥ Œ±
  NeuApp :: Neutral Œ≥ (Œ± ‚ü∂ Œ≤) -> NF Œ≥ Œ± -> Neutral Œ≥ Œ≤
  NeuFst :: Neutral Œ≥ (Œ± √ó Œ≤) -> Neutral Œ≥ Œ±
  NeuSnd :: Neutral Œ≥ (Œ± √ó Œ≤) -> Neutral Œ≥ Œ≤
  NeuTT :: Neutral Œ≥ Unit

data NF Œ≥ Œ± where
  NFLam :: NF (Œ≥ √ó Œ±) Œ≤ -> NF Œ≥ (Œ± ‚ü∂ Œ≤)
  NFPair :: NF Œ≥ Œ± -> NF Œ≥ Œ≤ -> NF Œ≥ (Œ± √ó Œ≤)
  Neu :: Neutral Œ≥ Œ± -> NF Œ≥ Œ±

wknNF :: NF Œ≥ Œ± -> NF (Œ≥ √ó Œ≤) Œ±
wknNF = renameNF Weaken

exchNF :: NF ((Œ≥ √ó Œ±) √ó Œ≤) œâ -> NF ((Œ≥ √ó Œ≤) √ó Œ±) œâ
exchNF = renameNF $ \case
  Get -> Weaken Get
  Weaken Get -> Get
  Weaken (Weaken i) -> Weaken $ Weaken i

substNeu :: Neutral Œ≥ Œ± -> (forall Œ≤.Œ≤ ‚àà Œ≥ -> NF Œ¥ Œ≤) -> NF Œ¥ Œ±
substNeu (NeuVar i) f = f i
substNeu (NeuCon c) _ = Neu $ NeuCon c
substNeu (NeuApp m n) f = case substNeu m f of
                            NFLam m' -> substNF0 m' (substNF n f)
                            Neu m' -> Neu $ NeuApp m' (substNF n f)
substNeu (NeuFst m) f = case substNeu m f of
                          NFPair m' n' -> m'
                          Neu m' -> Neu $ NeuFst m'
substNeu (NeuSnd m) f = case substNeu m f of
                          NFPair m' n' -> n'
                          Neu m' -> Neu $ NeuSnd m'
substNeu NeuTT f = Neu NeuTT
                            
substNF :: NF Œ≥ Œ± -> (forall Œ≤.Œ≤ ‚àà Œ≥ -> NF Œ¥ Œ≤) -> NF Œ¥ Œ±
substNF (NFLam m) f = NFLam $ substNF m $ \case
  Get -> Neu $ NeuVar Get
  Weaken i -> wknNF $ f i
substNF (NFPair m n) f = NFPair (substNF m f) (substNF n f)
substNF (Neu m) f = substNeu m f

substNF0 :: NF (Œ≥ √ó Œ±) Œ≤ -> NF Œ≥ Œ± -> NF Œ≥ Œ≤
substNF0 m t = substNF m $ \case
  Get -> t
  (Weaken i) -> Neu $ NeuVar i

normalForm :: Œ≥ ‚ä¢ Œ± -> NF Œ≥ Œ±
normalForm (Var i) = Neu $ NeuVar i
normalForm (Con c) = Neu $ NeuCon c
normalForm (App (normalForm -> m) (normalForm -> n))
  = case m of
      NFLam m' -> substNF0 m' n
      Neu m' -> Neu $ NeuApp m' n
normalForm (Lam (normalForm -> m)) = NFLam m
normalForm (Fst (normalForm -> m))
  = case m of
      NFPair m' n' -> m'
      Neu m' -> Neu $ NeuFst m'
normalForm (Snd (normalForm -> m))
  = case m of
      NFPair m' n' -> n'
      Neu m' -> Neu $ NeuSnd m'
normalForm (Pair (normalForm -> m) (normalForm -> n)) = NFPair m n
normalForm TT = Neu NeuTT

nf_to_Œª :: NF Œ≥ Œ± -> Œ≥ ‚ä¢ Œ±
nf_to_Œª (Neu (neu_to_Œª -> m)) = m
nf_to_Œª (NFLam (nf_to_Œª -> m)) = Lam m
nf_to_Œª (NFPair (nf_to_Œª -> m) (nf_to_Œª -> n)) = Pair m n

neu_to_Œª :: Neutral Œ≥ Œ± -> Œ≥ ‚ä¢ Œ±
neu_to_Œª (NeuVar i) = Var i
neu_to_Œª (NeuCon c) = Con c
neu_to_Œª (NeuApp (neu_to_Œª -> m) (nf_to_Œª -> n)) = App m n
neu_to_Œª (NeuFst (neu_to_Œª -> m)) = Fst m
neu_to_Œª (NeuSnd (neu_to_Œª -> m)) = Snd m
neu_to_Œª NeuTT = TT

evalŒ≤ :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
evalŒ≤ = nf_to_Œª . normalForm

instance Show (Œ≥ ‚ä¢ Œ±) where
  show (Var Get) = "x"
  show (Var (Weaken i)) = show (Var i) ++ "'"
  show (App (App (Con (Logical And)) p) q)
    = "(" ++ show p ++ " ‚àß " ++ show q ++ ")"
  show (App (App (Con (Logical Or)) p) q)
    = "(" ++ show p ++ " ‚à® " ++ show q ++ ")"
  show (App (App (Con (Logical Imp)) p) q)
    = "(" ++ show p ++ " ‚Üí " ++ show q ++ ")"
  show (App (App (Con (Logical Equals)) m) n)
    = "(" ++ show m ++ " = " ++ show n ++ ")"
  show (App (App (Con (Rl Mult)) m) n)
    = "(" ++ show m ++ " * " ++ show n ++ ")"
  show (App (App (Con (Rl Divi)) m) n)
    = "(" ++ show m ++ " / " ++ show n ++ ")"
  show (App (App (Con (Rl EqGen)) m) n)
    = "(" ++ show m ++ " ‚âê " ++ show n ++ ")"
  show (App (App (Con (Rl EqRl)) m) n)
    = "(" ++ show m ++ " ‚âê " ++ show n ++ ")"
  show (App (App (Con (Special GTE)) m) n)
    = "(" ++ show m ++ " ‚â• " ++ show n ++ ")"
  show (App (App (Con (Special Upd)) m) n)
    = show m ++ "‚à∑" ++ show n
  show (App m n) = show m ++ "(" ++ show n ++ ")"
  show (Con c) = show c
  show (Lam m) = "Œª(" ++ show m ++ ")"
  show (Fst m) = "(œÄ‚ÇÅ " ++ show m ++ ")"
  show (Snd m) = "(œÄ‚ÇÇ" ++ show m ++ ")"
  show TT = "‚ãÑ"
  show (Pair m n) = "‚ü®" ++ show m ++ ", " ++ show n ++ "‚ü©"

lft :: (Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> Œ± ‚àà (Œ≥ √ó Œ≤) -> Œ± ‚àà (Œ¥ √ó Œ≤)
lft f Get = Get
lft f (Weaken i) = Weaken $ f i

œÄ :: Œ± ‚àà Œ∫ -> Œ≥ ‚ä¢ Œ∫ -> Œ≥ ‚ä¢ Œ±
œÄ Get Œ≥ = Snd Œ≥
œÄ (Weaken i) Œ≥ = œÄ i (Fst Œ≥)

type Context
  = (((((((Unit
            √ó (Œì ‚ü∂ E))
           √ó (E ‚ü∂ (Œì ‚ü∂ Œì)))
          √ó Œì)
         √ó (R ‚ü∂ (R ‚ü∂ T))
        √ó R)
       √ó (E ‚ü∂ T))
      √ó (E ‚ü∂ R))
     √ó E)

findC :: Special Œ± -> Œ± ‚àà Context
findC Vlad = Get
findC Height = Weaken Get
findC Human = Weaken (Weaken Get)
findC Theta = Weaken (Weaken (Weaken Get))
findC GTE = Weaken (Weaken (Weaken (Weaken (Get))))
findC Empty = Weaken (Weaken (Weaken (Weaken (Weaken Get))))
findC Upd = Weaken (Weaken (Weaken (Weaken (Weaken (Weaken Get)))))
findC Sel = Weaken (Weaken (Weaken (Weaken (Weaken (Weaken (Weaken Get))))))
                   
rename :: (‚àÄŒ±. Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> Œ≥ ‚ä¢ Œ≤ -> Œ¥ ‚ä¢ Œ≤
rename f (Var i) = Var $ f i
rename f (Con c) = (Con c)
rename f (App m n) = App (rename f m) (rename f n)
rename f (Lam m) = Lam $ rename (lft f) m
rename f (Fst m) = Fst $ rename f m
rename f (Snd m) = Snd $ rename f m
rename f TT = TT
rename f (Pair m n) = Pair (rename f m) (rename f n)

renameNeu :: (forall Œ±. Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> Neutral Œ≥ Œ≤ -> Neutral Œ¥ Œ≤
renameNeu f = \case
  NeuVar i -> NeuVar $ f i
  NeuCon c -> NeuCon c
  NeuApp (renameNeu f -> m) (renameNF f -> n) -> NeuApp m n
  NeuFst (renameNeu f -> m) -> NeuFst m
  NeuSnd (renameNeu f -> m) -> NeuSnd m
  NeuTT -> NeuTT

renameNF :: (forall Œ±. Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> NF Œ≥ Œ≤ -> NF Œ¥ Œ≤
renameNF f = \case
  (Neu (renameNeu f -> m)) -> Neu m
  (NFLam (renameNF (lft f) -> m)) -> NFLam m
  (NFPair (renameNF f -> m) (renameNF f -> n)) -> NFPair m n

wkn :: Œ≥ ‚ä¢ Œ± -> (Œ≥ √ó Œ≤) ‚ä¢ Œ±
wkn = rename Weaken

exch :: ((Œ≥ √ó Œ±) √ó Œ≤) ‚ä¢ œâ -> ((Œ≥ √ó Œ≤) √ó Œ±) ‚ä¢ œâ
exch = rename $ \case
  Get -> Weaken Get
  Weaken Get -> Get
  (Weaken (Weaken i)) -> Weaken (Weaken i)

contr :: ((Œ≥ √ó Œ±) √ó Œ±) ‚ä¢ Œ≤ -> (Œ≥ √ó Œ±) ‚ä¢ Œ≤
contr = rename $ \case
  Get -> Get
  Weaken i -> i

hmorph0 :: Œ≥ ‚ä¢ Œ± -> (Œ≥ √ó Context) ‚ä¢ Œ±
hmorph0 (Var i) = Var (Weaken i)
hmorph0 (App m n) = App (hmorph0 m) (hmorph0 n)
hmorph0 (Lam m) = Lam $ exch (hmorph0 m)
hmorph0 (Fst m) = Fst $ hmorph0 m
hmorph0 (Snd m) = Snd $ hmorph0 m
hmorph0 (Pair m n) = Pair (hmorph0 m) (hmorph0 n)
hmorph0 (Con (Special c)) = œÄ (findC c) (Var Get)
hmorph0 (Con c) = Con c

hmorph :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ (Context ‚ü∂ Œ±)
hmorph m = Lam (hmorph0 m)

Œ∑ :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ ((Œ± ‚ü∂ R) ‚ü∂ R)
Œ∑ m = Lam (App (Var Get) (wkn m))

(>>=) :: Œ≥ ‚ä¢ ((Œ± ‚ü∂ R) ‚ü∂ R) -> Œ≥ ‚ä¢ (Œ± ‚ü∂ ((Œ≤ ‚ü∂ R) ‚ü∂ R)) -> Œ≥ ‚ä¢ ((Œ≤ ‚ü∂ R) ‚ü∂ R)
m >>= k = Lam (App (wkn m)
               (Lam (App (App (wkn (wkn k)) (Var Get)) (Var (Weaken Get)))))

(>>) :: Œ≥ ‚ä¢ ((Unit ‚ü∂ R) ‚ü∂ R) -> Œ≥ ‚ä¢ ((Œ≤ ‚ü∂ R) ‚ü∂ R) -> Œ≥ ‚ä¢ ((Œ≤ ‚ü∂ R) ‚ü∂ R)
m >> k = m >>= Lam (wkn k)
