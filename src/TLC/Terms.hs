{-# LANGUAGE DataKinds #-}
{-# LANGUAGE EmptyCase #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ViewPatterns #-}


module TLC.Terms where

import Algebra.Classes
import Data.Ratio
import Data.String.Utils
import Prelude hiding ((>>), Num(..))


data Type = E | 'T | R | U | 'Œì
          | Type :-> Type
          | Unit
          | Type :√ó Type

data (Œ± :: Type) ‚àà (Œ≥ :: Type) where
  Get :: Œ± ‚àà (Œ≥ √ó Œ±)
  Weaken :: Œ± ‚àà Œ≥ -> Œ± ‚àà (Œ≥ √ó Œ≤)
deriving instance Show (Œ± ‚àà Œ≥)
deriving instance Eq (Œ± ‚àà Œ≥)
deriving instance Ord (Œ± ‚àà Œ≥) -- do not change this instance, it is used for testing deepness of variables

type Œ± √ó Œ≤ = Œ± ':√ó Œ≤
type Œ± ‚ü∂ Œ≤ = Œ± ':-> Œ≤
infixr ‚ü∂
infixr :->

(‚âê) :: Equality Œ± => Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ 'R
m ‚âê n = App (Con (General EqGen)) (Pair m n)

noOccur :: (Œ± ‚àà (Œ≥ √ó x)) -> Maybe (Œ± ‚àà Œ≥)
noOccur = \case
  Get -> Nothing
  Weaken x -> Just x

pattern NCon x = Neu (NeuCon x)
pattern NVar x = Neu (NeuVar x)
class Equality Œ± where
  equals :: forall Œ≥. NF Œ≥ Œ± -> NF Œ≥ Œ± -> NF Œ≥ 'R
instance Equality 'E where
  equals (NCon (Special (Entity m))) (NCon (Special (Entity n))) =
    NCon $ General $ Incl $ case m == n of True -> 1; False -> 0
  equals x y = Neu $ NeuApp (NeuCon (General EqGen)) (NFPair x y) 
instance Equality 'R where
  equals (NCon (General (Incl x))) (NCon (General (Incl y)))
    = case x == y of
        True -> one
        False -> NCon $ General $ Incl 0
  equals (NCon (Special (Degree m))) (NCon (Special (Degree n))) =
          NCon $ General $ Incl $ case m == n of True -> 1; False -> 0
  equals x y = Neu $ NeuCon (General EqRl) `NeuApp` x `NeuApp` y
instance Equality 'U where
  equals (NCon (General (Utt i))) (NCon (General (Utt j))) = case i == j of
                             True -> one
                             False -> NCon (General (Incl 0))
  equals (Neu (NeuApp (NeuCon (General Utt')) x))
    (Neu (NeuApp (NeuCon (General Utt')) y)) = equals x y
  equals (NCon (General (Utt'' es0))) (NCon (General (Utt'' es1))) =
    checkEquality es0 es1
    where checkEquality :: [Maybe (Special 'E)] -> [Maybe (Special 'E)]
                        -> NF Œ≥ 'R
          checkEquality [] [] = one
          checkEquality (Nothing:es0) (Nothing:es1) = checkEquality es0 es1
          checkEquality (Just _ : _) (Nothing:_) = NCon (General (Incl 0))
          checkEquality (Nothing:_) (Just _ : _) = NCon (General (Incl 0))
          checkEquality (Just x : es0) (Just y : es1) =
            equals (NCon $ Special x) (NCon $ Special y) * checkEquality es0 es1
  equals m n = Neu $ (NeuCon $ General $ EqGen) `NeuApp` (NFPair m n)
instance Equality Unit where
  equals _ _ = one
instance (Equality Œ±, Equality Œ≤) => Equality (Œ± √ó Œ≤) where
  equals (NFPair m n) (NFPair m' n') = equals m m' * equals n n'
  equals m n = Neu $ (NeuCon $ General $ EqGen) `NeuApp` (NFPair m n)
instance Equality ('E ‚ü∂ 'R) where
  equals :: forall Œ≥. NF Œ≥ ('E ‚ü∂ 'R) -> NF Œ≥ ('E ‚ü∂ 'R) -> NF Œ≥ 'R
  equals (NCon (Special (MeasureFun m))) (NCon (Special (MeasureFun n))) =
    NCon $ General $ Incl $ case m == n of True -> 1; False -> 0
  equals (NFLam m) (NFLam n)
    | Just x <- traverseNF noOccur (equals m n) = x
  equals t u = Neu ((NeuCon $ General $ EqGen) `NeuApp` (NFPair t u))
instance Equality ('E ‚ü∂ 'T) where
  equals (NCon (Special (Property m))) (NCon (Special (Property n))) =
    NCon $ General $ Incl $ case m == n of True -> 1; False -> 0
instance Equality ('E ‚ü∂ 'E ‚ü∂ 'T) where
  equals (NCon (Special (Relation m))) (NCon (Special (Relation n))) =
    NCon $ General $ Incl $ case m == n of True -> 1; False -> 0
instance Equality ('R ‚ü∂ 'R ‚ü∂ 'T) where
  equals (NCon (Special GTE)) (NCon (Special GTE)) = one
instance Equality 'Œì where
  equals (NCon (General Empty)) (NCon (General Empty)) = one
instance Equality ('E ‚ü∂ 'Œì ‚ü∂ 'Œì) where
  equals (NCon (General Upd)) (NCon (General Upd)) = one
instance Equality ('Œì ‚ü∂ 'E) where
  equals (NCon (Special (Sel i))) (NCon (Special (Sel j))) =
    case i == j of
      True -> one
      False -> NCon (General (Incl 0))
  equals (NCon (General (Pi i))) (NCon (General (Pi j))) =
    case i == j of
      True -> one
      False -> NCon (General (Incl 0))

u :: Int -> Œ≥ ‚ä¢ 'U
u i = Con $ General $ Utt i

u' :: Œ≥ ‚ä¢ 'R -> Œ≥ ‚ä¢ 'U
u' = App $ Con $ General Utt'

u'' :: [Maybe (Special 'E)] -> NF Œ≥ 'U
u'' as = Neu $ NeuCon $ General $ Utt'' as


prop i = Con $ Special $ Property i
rel i = Con $ Special $ Relation i
vlad = Con $ Special Vlad
jp = Con $ Special JP
entity i = Con $ Special $ Entity i
height = Con $ Special Height
human = Con $ Special Human
Œ∏ = Con $ Special Theta
(‚â•) = Con $ Special GTE
emp = Con $ General Empty
upd = Con $ General Upd
upd' x c = App (App upd x) c
sel n = Con $ Special $ Sel n
sel' n c = App (sel n) c

(/\) :: Œ≥ ‚ä¢ 'T -> Œ≥ ‚ä¢ 'T -> Œ≥ ‚ä¢ 'T
p /\ q = App (App (Con (Logical And)) p) q

(\/) :: Œ≥ ‚ä¢ 'T -> Œ≥ ‚ä¢ 'T -> Œ≥ ‚ä¢ 'T
p \/ q = App (App (Con (Logical Or)) p) q

(-->) :: Œ≥ ‚ä¢ 'T -> Œ≥ ‚ä¢ 'T -> Œ≥ ‚ä¢ 'T
p --> q = App (App (Con (Logical Imp)) p) q

exists :: Œ≥ ‚ä¢ (Œ± ‚ü∂ 'T) -> Œ≥ ‚ä¢ 'T
exists œÜ = App (Con (Logical Exists)) œÜ

reduce1step :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
reduce1step = \case
  App (App (Con (General Mult)) (Con (General (Incl 1)))) (reduce1step -> n) -> n
  App (App (Con (General Mult)) (reduce1step -> m)) (Con (General (Incl 1))) -> m
  Var i -> Var i
  Con c -> Con c
  App (reduce1step -> m) (reduce1step -> n) -> App m n
  Lam (reduce1step -> m) -> Lam m
  Fst (reduce1step -> m) -> Fst m
  Snd (reduce1step -> m) -> Snd m
  TT -> TT
  Pair (reduce1step -> m) (reduce1step -> n) -> Pair m n

can'Reduce :: Œ≥ ‚ä¢ Œ± -> Bool
can'Reduce = \case
  App (Con (General Mult)) (Con (General (Incl 1))) -> True
  App (App (Con (General Mult)) x) (Con (General (Incl 1))) -> True
  Var i -> False
  Con c -> False
  App (can'Reduce -> m) (can'Reduce -> n) -> m || n
  Lam m -> can'Reduce m
  Fst m -> can'Reduce m
  Snd m -> can'Reduce m
  TT -> False
  Pair (can'Reduce -> m) (can'Reduce -> n) -> m || n

reduce1s :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
reduce1s m = if can'Reduce m then reduce1s (reduce1step m) else m

clean :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
clean = reduce1s . evalŒ≤ 

showR :: Rational -> String
showR (\x -> (numerator x, denominator x) -> (num, den))
  = case (num, den) of
      (0, _) -> "0"
      (_, 1) -> show num
      (_, _) -> "(" ++ show num ++ " / " ++ show den ++ ")"

data Logical Œ± where
  Tru :: Logical 'T
  Fal :: Logical 'T
  And :: Logical ('T ‚ü∂ 'T ‚ü∂ 'T)
  Or :: Logical ('T ‚ü∂ 'T ‚ü∂ 'T)
  Imp :: Logical ('T ‚ü∂ 'T ‚ü∂ 'T)
  Forall :: Logical ((Œ± ‚ü∂ 'T) ‚ü∂ 'T)
  Exists :: Logical ((Œ± ‚ü∂ 'T) ‚ü∂ 'T)
  Equals :: Logical (Œ± ‚ü∂ Œ± ‚ü∂ 'T)

pattern True' = Con (Logical Tru)
pattern False' = Con (Logical Fal)
pattern And' œÜ œà = App (App (Con (Logical And)) œÜ) œà
pattern Or' œÜ œà = App (App (Con (Logical Or)) œÜ) œà
pattern Imp' œÜ œà = App (App (Con (Logical Imp)) œÜ) œà
pattern Forall' f = App (Con (Logical Forall)) f
pattern Exists' f = App (Con (Logical Exists)) f
pattern Equals' m n = App (App (Con (Logical Equals)) m) n

instance Show (Logical Œ±) where
  show Tru = "‚ä§"
  show Fal = "‚ä•"
  show And = "(‚àß)"
  show Or = "(‚à®)"
  show Imp = "(‚Üí)"
  show Forall = "‚àÄ"
  show Exists = "‚àÉ"
  show Equals = "(=)"
 
data General Œ± where
  Incl :: Rational -> General 'R
  Indi :: General ('T ‚ü∂ 'R)
  Addi :: General ('R ‚ü∂ 'R ‚ü∂ 'R)
  Mult :: General ('R ‚ü∂ 'R ‚ü∂ 'R)
  Expo :: General ('R ‚ü∂ 'R ‚ü∂ 'R)
  Divi :: General ('R ‚ü∂ 'R ‚ü∂ 'R)
  EqGen :: Equality Œ± => General ((Œ± √ó Œ±) ‚ü∂ 'R)
  EqRl :: General ('R ‚ü∂ 'R ‚ü∂ 'R)
  Utt :: Int -> General 'U
  Utt' :: General ('R ‚ü∂ 'U)
  Utt'' :: [Maybe (Special 'E)] -> General 'U
  MakeUtts :: Witness n -> General ((Context n √ó 'U) ‚ü∂ (('U ‚ü∂ 'R) ‚ü∂ 'R))
  Cau :: General (('R √ó 'R) ‚ü∂ ('R ‚ü∂ 'R) ‚ü∂ 'R)
  Les :: General (('R ‚ü∂ 'R) ‚ü∂ 'R)
  Nml :: General (('R √ó 'R) ‚ü∂ ('R ‚ü∂ 'R) ‚ü∂ 'R)
  Qua :: General (('R √ó 'R) ‚ü∂ ('R ‚ü∂ 'R) ‚ü∂ 'R)
  Uni :: General (('R √ó 'R) ‚ü∂ ('R ‚ü∂ 'R) ‚ü∂ 'R)
  Interp :: Witness n -> General ('U ‚ü∂ Context n ‚ü∂ 'T)
  Empty :: General 'Œì
  Upd :: General ('E ‚ü∂ 'Œì ‚ü∂ 'Œì)
  Pi :: Int -> General ('Œì ‚ü∂ 'E)

instance Additive (Œ≥ ‚ä¢ 'R) where
  zero = Con (General (Incl 0))
  x + y  = Con (General Addi) `App` x `App` y
instance Additive (NF Œ≥ 'R) where
  zero = normalForm zero
  x + y = normalForm (nf_to_Œª x + nf_to_Œª y)
instance AbelianAdditive (Œ≥ ‚ä¢ 'R)
instance AbelianAdditive (NF Œ≥ 'R)
instance Group (Œ≥ ‚ä¢ 'R) where
  negate = App (App (Con (General Mult)) (Con (General (Incl (-1)))))
instance Group (NF Œ≥ 'R) where
  negate = normalForm . negate . nf_to_Œª
instance Multiplicative (Œ≥ ‚ä¢ 'R) where
  one = Con (General (Incl 1))
  x * y  = Con (General Mult) `App` x `App` y
  x ^+ n = Con (General Expo) `App` x `App` Con (General (Incl (fromInteger n)))
instance Multiplicative (NF Œ≥ 'R) where
  one = normalForm one
  x * y = normalForm (nf_to_Œª x * nf_to_Œª y)
instance Division (Œ≥ ‚ä¢ 'R) where
  x / y  = Con (General Divi) `App` x `App` y
instance Division (NF Œ≥ 'R) where
  x / y = normalForm (nf_to_Œª x Algebra.Classes./ nf_to_Œª y)
instance Roots (Œ≥ ‚ä¢ 'R) where
  x ^/ n = Con (General Expo) `App` x `App` Con (General (Incl n))
instance Show (General Œ±) where
  show (Incl x) = showR x
  show Indi = "ùüô"
  show Expo = "(^)"
  show Addi = "(+)"
  show Mult = "(*)"
  show Divi = "(/)"
  show Nml = "Normal"
  show Uni = "Uniform"
  show Cau = "Cauchy"
  show Les = "Lesbegue"
  show EqGen = "(‚âê)"
  show EqRl = "(‚â°)"
  show (Utt i) = "'U" ++ show i
  show Utt' = "'U"
  show (Utt'' as) = "U" ++ show as
  show (Interp _) = "‚ü¶‚üß"
  show Empty = "Œµ"
  show Upd = "(‚à∑)"
  show (Pi n) = "œÄ" ++ show n
  show (MakeUtts _) = "MakeUtts"

data Special Œ± where
  Entity :: Int -> Special 'E
  MeasureFun :: Int -> Special ('E ‚ü∂ 'R)
  Property :: Int -> Special ('E ‚ü∂ 'T)
  Relation :: Int -> Special ('E ‚ü∂ 'E ‚ü∂ 'T)
  Degree :: Int -> Special 'R
  GTE :: Special ('R ‚ü∂ 'R ‚ü∂ 'T)
  Sel :: Int -> Special ('Œì ‚ü∂ 'E)

pattern JP = Entity 0
pattern Vlad = Entity 1
pattern Height = MeasureFun 1
pattern Human = Property 1
pattern Theta = Degree 1
  
instance Show (Special Œ±) where
  show JP = "jp"
  show Vlad = "v"
  show (Entity n) = "entity" ++ show n
  show Height = "height"
  show (MeasureFun n) = "measurefun" ++ show n
  show Human = "human"
  show (Property n) = "property" ++ show n
  show (Relation n) = "relation" ++ show n
  show Theta = "Œ∏"
  show (Degree n) = "degree" ++ show n
  show GTE = "(‚â•)"
  show (Sel n) = "sel" ++ show n

data Con Œ± where
  Logical :: Logical Œ± -> Con Œ±
  General :: General Œ± -> Con Œ±
  Special :: Special Œ± -> Con Œ±

instance Show (Con Œ±) where
  show (Logical c) = show c
  show (General c) = show c
  show (Special c) = show c

-- Well-typed terms.
data Œ≥ ‚ä¢ Œ± where
  Var :: Œ± ‚àà Œ≥ -> Œ≥ ‚ä¢ Œ±
  Con :: Con Œ± -> Œ≥ ‚ä¢ Œ±
  App :: Œ≥ ‚ä¢ (Œ± ‚ü∂ Œ≤) -> Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ≤
  Lam :: (Œ≥ √ó Œ±) ‚ä¢ Œ≤ -> Œ≥ ‚ä¢ (Œ± ‚ü∂ Œ≤)
  Fst :: Œ≥ ‚ä¢ (Œ± √ó Œ≤) -> Œ≥ ‚ä¢ Œ±
  Snd :: Œ≥ ‚ä¢ (Œ± √ó Œ≤) -> Œ≥ ‚ä¢ Œ≤
  TT :: Œ≥ ‚ä¢ Unit
  Pair :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ≤ -> Œ≥ ‚ä¢ (Œ± √ó Œ≤)

infixl `App`

absInversion :: Œ≥ ‚ä¢ ('R ‚ü∂ Œ±) -> (Œ≥ √ó 'R) ‚ä¢ Œ±
absInversion (Lam f) = f
absInversion t = App (wkn t) (Var Get)

-- Neutral terms (no constructors, except in arguments).
data Neutral Œ≥ Œ± where
  NeuVar :: Œ± ‚àà Œ≥ -> Neutral Œ≥ Œ±
  NeuCon :: Con Œ± -> Neutral Œ≥ Œ±
  NeuApp :: Neutral Œ≥ (Œ± ‚ü∂ Œ≤) -> NF Œ≥ Œ± -> Neutral Œ≥ Œ≤
  NeuFst :: Neutral Œ≥ (Œ± √ó Œ≤) -> Neutral Œ≥ Œ±
  NeuSnd :: Neutral Œ≥ (Œ± √ó Œ≤) -> Neutral Œ≥ Œ≤
  NeuTT :: Neutral Œ≥ Unit

-- Terms in normal form.
data NF Œ≥ Œ± where
  NFLam :: NF (Œ≥ √ó Œ±) Œ≤ -> NF Œ≥ (Œ± ‚ü∂ Œ≤)
  NFPair :: NF Œ≥ Œ± -> NF Œ≥ Œ≤ -> NF Œ≥ (Œ± √ó Œ≤)
  Neu :: Neutral Œ≥ Œ± -> NF Œ≥ Œ±

traverseNF :: Applicative f => (forall x. x ‚àà Œ≥ -> f (x ‚àà Œ¥)) -> NF Œ≥ Œ± -> f (NF Œ¥ Œ±)
traverseNF f = \case
  NFLam x -> NFLam <$> traverseNF (lft' f) x
  NFPair x y ->NFPair <$> traverseNF f x <*> traverseNF f y
  Neu x -> Neu <$> traverseNeu f x

traverseNeu :: Applicative f => (forall x. x ‚àà Œ≥ -> f (x ‚àà Œ¥)) -> Neutral Œ≥ Œ± -> f (Neutral Œ¥ Œ±)
traverseNeu f = \case
  NeuVar x -> NeuVar <$> f x
  NeuCon x -> pure (NeuCon x)
  NeuApp t u -> NeuApp <$> traverseNeu f t <*> traverseNF f u 
  NeuFst t -> NeuFst <$>  traverseNeu f t
  NeuSnd t -> NeuSnd <$>  traverseNeu f t
  NeuTT -> pure NeuTT 
  
absInversionNF :: NF Œ≥ ('R ‚ü∂ Œ±) -> NF (Œ≥ √ó 'R) Œ±
absInversionNF (NFLam f) = f
absInversionNF (Neu t) = Neu (NeuApp (renameNeu Weaken t) (Neu (NeuVar Get)))

wknNF :: NF Œ≥ Œ± -> NF (Œ≥ √ó Œ≤) Œ±
wknNF = renameNF Weaken

exchNF :: NF ((Œ≥ √ó Œ±) √ó Œ≤) œâ -> NF ((Œ≥ √ó Œ≤) √ó Œ±) œâ
exchNF = renameNF $ \case
  Get -> Weaken Get
  Weaken Get -> Get
  Weaken (Weaken i) -> Weaken $ Weaken i

substNeu :: Neutral Œ≥ Œ± -> (forall Œ≤.Œ≤ ‚àà Œ≥ -> NF Œ¥ Œ≤) -> NF Œ¥ Œ±
substNeu (NeuVar i) f = f i
substNeu (NeuCon c) _ = Neu $ NeuCon c
substNeu (NeuApp m n) f = apply (substNeu m f) (substNF n f)
substNeu (NeuFst m) f = fst' (substNeu m f)
substNeu (NeuSnd m) f = snd' (substNeu m f)
substNeu NeuTT _ = Neu NeuTT
                            
substNF :: NF Œ≥ Œ± -> (forall Œ≤.Œ≤ ‚àà Œ≥ -> NF Œ¥ Œ≤) -> NF Œ¥ Œ±
substNF (NFLam m) f = NFLam $ substNF m $ \case
  Get -> Neu $ NeuVar Get
  Weaken i -> wknNF $ f i
substNF (NFPair m n) f = NFPair (substNF m f) (substNF n f)
substNF (Neu m) f = substNeu m f

substNF0 :: NF (Œ≥ √ó Œ±) Œ≤ -> NF Œ≥ Œ± -> NF Œ≥ Œ≤
substNF0 m t = substNF m $ \case
  Get -> t
  (Weaken i) -> Neu $ NeuVar i

apply :: NF Œ≥ (Œ±1 ‚ü∂ Œ±2) -> NF Œ≥ Œ±1 -> NF Œ≥ Œ±2
apply t u = case t of
    NFLam m' -> substNF0 m' u -- Œ≤ rule
    Neu m' -> case m' of      -- Œ¥ rules
      (NeuCon (General (Pi i))) -> listFromContext u !! i
      (NeuCon (General (MakeUtts n))) ->
        case u of
          NFPair k (Neu (NeuCon u''))
            -> if checkk n k then makeUtts' n k (Neu (NeuCon u'')) else deflt
          _ -> deflt
        where checkk :: Witness n -> NF Œ≥ (Context n) -> Bool
              checkk (S Z) = \case
                NFPair (NFPair _ (Neu (NeuCon (Special _))))
                  (Neu (NeuCon (Special _))) -> True
                _ -> False
              checkk (S (S Z)) = \case
                NFPair (NFPair _ (Neu (NeuCon (Special _))))
                  (Neu (NeuCon (Special _))) -> True
                _ -> False
      (NeuCon (General EqGen)) -> equals (fst' u) (snd' u)
      (NeuCon (General (Interp i))) -> case nf_to_Œª u of
         Con (General (Utt 1)) -> morph $ App (App (‚â•) (App height vlad)) Œ∏ -- 'Vlad is tall'
         Con (General (Utt 2)) -> morph $ App (App (‚â•) Œ∏) (App height vlad) -- 'Vlad is not tall'
         Con (General (Utt 3)) -> morph $ Con $ Logical Tru -- silence
         App (Con (General Utt')) x ->
           morph $ App (App (‚â•) (App height vlad)) x
         Con (General (Utt'' [Nothing])) -> morph $ App (prop 0) (sel' 0 ctx)
         Con (General (Utt'' [Just e0])) ->
           morph $ App (prop 0) (Con $ Special e0)
         Con (General (Utt'' [Nothing, Nothing]))
           -> morph $ App (App (rel 0) (sel' 0 ctx)) (sel' 1 ctx)
         Con (General (Utt'' [Just e0, Nothing])) ->
           morph $ App (App (rel 0) (Con $ Special e0)) (sel' 1 ctx)
         Con (General (Utt'' [Nothing, Just e1])) ->
           morph $ App (App (rel 0) (sel' 0 ctx)) (Con $ Special e1)
         Con (General (Utt'' [Just e0, Just e1])) ->
           morph $ App (App (rel 0) (Con $ Special e0)) (Con $ Special e1)
         _ -> deflt
         where morph = normalForm . hmorph i
               ctx = upd' jp (upd' vlad emp) 
      _ -> deflt
      where deflt = Neu (NeuApp m' u)
            listFromContext :: NF Œ≥ 'Œì -> [NF Œ≥ 'E]
            listFromContext u = case nf_to_Œª u of
              Con (General Empty) -> []
              App (App (Con (General Upd)) x) c
                -> normalForm x : listFromContext (normalForm c)

toFinite :: [NF Œ≥ Œ±] -> NF Œ≥ ((Œ± ‚ü∂ 'R) ‚ü∂ 'R)
toFinite [] = NFLam $ normalForm zero
toFinite (t:ts) = NFLam $ (Neu $ NeuApp (NeuVar Get) (wknNF t)) +
                  case toFinite (map wknNF ts) of
                    NFLam m -> substNF0 m (Neu (NeuVar Get))
                    Neu m -> Neu $ NeuApp m (Neu (NeuVar Get))

makeUtts :: [Special 'E] -> General 'U -> NF Œ≥ (('U ‚ü∂ 'R) ‚ü∂ 'R)
makeUtts [e0, e1] = \case
  Utt'' [Nothing, Nothing] -> toFinite $
    u'' [Nothing, Nothing] :
    [ u'' [Just e0', Nothing] | e0' <- [e0, e1] ] ++
    [ u'' [Nothing, Just e1'] | e1' <- [e0, e1] ] ++
    [ u'' [Just e0', Just e1'] | e0' <- [e0, e1], e1' <- [e0, e1] ]
  Utt'' [Just e0', Nothing] -> toFinite $
    u'' [Just e0', Nothing] : [ u'' [Just e0', Just e1'] | e1' <- [e0, e1] ]
  Utt'' [Nothing, Just e1'] -> toFinite $
    u'' [Nothing, Just e1'] : [ u'' [Just e0', Just e1'] | e0' <- [e0, e1] ]
  u@(Utt'' [Just _, Just _]) -> normalForm $ Œ∑ $ Con $ General u
  Utt'' [Nothing] -> toFinite $
    [ u'' [Just e0'] | e0' <- [e0, e1] ]
  u@(Utt'' [Just _]) -> normalForm $ Œ∑ $ Con $ General u

makeUtts' :: Witness n -> NF Œ≥ (Context n) -> NF Œ≥ 'U -> NF Œ≥ (('U ‚ü∂ 'R) ‚ü∂ 'R)
makeUtts' (S Z) k u =
  let Pair (Pair _ (Con (Special e0))) (Con (Special e1)) = nf_to_Œª k
      Con (General u') = nf_to_Œª u
  in makeUtts [e0, e1] u'
makeUtts' (S (S Z)) k u =
  let Pair (Pair _ (Con (Special e0))) (Con (Special e1)) = nf_to_Œª k
      Con (General u') = nf_to_Œª u
  in makeUtts [e0, e1] u'

-- >>> makeUtts [Vlad, JP] $ Utt'' [Nothing, Nothing]
-- Œª((x(U[Just v,Just v]) + (x(U[Just v,Just jp]) + (x(U[Just jp,Just v]) + (x(U[Just jp,Just jp]) + 0)))))

normalForm :: Œ≥ ‚ä¢ Œ± -> NF Œ≥ Œ±
normalForm = \case
  Var i -> Neu $ NeuVar i
  Con c -> Neu $ NeuCon c
  App (normalForm -> m) (normalForm -> n) -> apply m n 
  Lam (normalForm -> m) -> NFLam m
  Fst (normalForm -> m) -> fst' m
  Snd (normalForm -> m) -> snd' m
  Pair (normalForm -> m) (normalForm -> n) -> NFPair m n
  TT -> Neu NeuTT

fst' :: NF Œ≥ (Œ± √ó Œ≤) -> NF Œ≥ Œ±
fst' = \case
           NFPair m' _ -> m'
           Neu m' -> Neu $ NeuFst m'

snd' :: NF Œ≥ (Œ±1 √ó Œ±2) -> NF Œ≥ Œ±2
snd' = \case
           NFPair _ n' -> n'
           Neu m' -> Neu $ NeuSnd m'

nf_to_Œª :: NF Œ≥ Œ± -> Œ≥ ‚ä¢ Œ±
nf_to_Œª = \case
  Neu (neu_to_Œª -> m) -> m
  NFLam (nf_to_Œª -> m) -> Lam m
  NFPair (nf_to_Œª -> m) (nf_to_Œª -> n) -> Pair m n

neu_to_Œª :: Neutral Œ≥ Œ± -> Œ≥ ‚ä¢ Œ±
neu_to_Œª = \case
  NeuVar i -> Var i
  NeuCon c -> Con c
  NeuApp (neu_to_Œª -> m) (nf_to_Œª -> n) -> App m n
  NeuFst (neu_to_Œª -> m) -> Fst m
  NeuSnd (neu_to_Œª -> m) -> Snd m
  NeuTT -> TT

evalŒ≤ :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ Œ±
evalŒ≤ = nf_to_Œª . normalForm

instance Show (NF Œ≥ Œ±) where
  show = show . nf_to_Œª
instance Show (Œ≥ ‚ä¢ Œ±) where
  show = replace "%" "/" . \case
    Var Get -> "x"
    Var (Weaken i) -> show (Var i) ++ "'"
    App (App (Con (Logical And)) (show -> p)) (show -> q)
      -> "(" ++ p ++ " ‚àß " ++ q ++ ")"
    App (App (Con (Logical Or)) (show -> p)) (show -> q)
      -> "(" ++ p ++ " ‚à® " ++ q ++ ")"
    App (App (Con (Logical Imp)) (show -> p)) (show -> q)
      -> "(" ++ p ++ " ‚Üí " ++ q ++ ")"
    App (App (Con (Logical Equals)) (show -> m)) (show -> n)
      -> "(" ++ m ++ " = " ++ n ++ ")"
    App (App (Con (General Addi)) (show -> m)) (show -> n)
      -> "(" ++ m ++ " + " ++ n ++ ")"
    App (App (Con (General Mult)) (show -> m)) (show -> n)
      -> "(" ++ m ++ " * " ++ n ++ ")"
    App (App (Con (General Divi)) (show -> m)) (show -> n)
      -> "(" ++ m ++ " / " ++ n ++ ")"
    App (Con (General EqGen)) (Pair (show -> m) (show -> n))
      -> "(" ++ m ++ " ‚âê " ++ n ++ ")"
    App (App (Con (General EqRl)) (show -> m)) (show -> n)
      -> "(" ++ m ++ " ‚âê " ++ n ++ ")"
    App (Con (General (Interp n))) (show -> u) -> "‚ü¶" ++ u ++ "‚üß"
    App (App (Con (General Upd)) (show -> m)) (show -> n)
      -> m ++ "‚à∑" ++ n
    App (App (Con (Special GTE)) (show -> m)) (show -> n)
      -> "(" ++ m ++ " ‚â• " ++ n ++ ")"
    App (show -> m) (show -> n) -> m ++ "(" ++ n ++ ")"
    Con (show -> c) -> c
    Lam (show -> m) -> "Œª(" ++ m ++ ")"
    Fst (show -> m) -> "(œÄ‚ÇÅ " ++ m ++ ")"
    Snd (show -> m) -> "(œÄ‚ÇÇ " ++ m ++ ")"
    TT -> "‚ãÑ"
    Pair (show -> m) (show -> n) -> "‚ü®" ++ m ++ ", " ++ n ++ "‚ü©"

displayDB :: Œ≥ ‚ä¢ Œ± -> IO ()
displayDB t = putStrLn $ show t

displayVs :: Unit ‚ä¢ Œ± -> IO ()
displayVs t = putStrLn $ replace "%" "/" $ displayVs' freshes (\case) t

freshes :: [String]
freshes = "" : map show ints >>= \i -> map (:i) ['x', 'y', 'z', 'u', 'v', 'w']
  where ints = 1 : map succ ints

displayVs1 :: (Unit √ó Œ≤)  ‚ä¢ Œ± -> String
displayVs1 t = case freshes of
  [] -> error "displayVs1: panic"
  f:fs -> displayVs' fs (\case Get -> f; Weaken _ -> "Œ≥") t

displayVs' :: forall Œ≥ Œ±.
              [String] -> (forall x. x ‚àà Œ≥ -> String) -> Œ≥ ‚ä¢ Œ± -> String
displayVs' fs œÅ t =
 let dd :: forall Œ≤. Œ≥ ‚ä¢ Œ≤ -> String
     dd = displayVs' fs œÅ
 in case t of
  Var v -> œÅ v
  App (App (Con (Logical And)) (dd -> p)) (dd -> q)
    -> "(" ++ p ++ " ‚àß " ++ q ++ ")"
  App (App (Con (Logical Or)) (dd -> p)) (dd -> q)
    -> "(" ++ p ++ " ‚à® " ++ q ++ ")"
  App (App (Con (Logical Imp)) (dd -> p)) (dd -> q)
    -> "(" ++ p ++ " ‚Üí " ++ q ++ ")"
  App (App (Con (Logical Equals)) (dd -> m)) (dd -> n)
    -> "(" ++ m ++ " = " ++ n ++ ")"
  App (App (Con (General Addi)) (dd -> m)) (dd -> n)
    -> "(" ++ m ++ " + " ++ n ++ ")"
  App (App (Con (General Mult)) (dd -> m)) (dd -> n)
    -> "(" ++ m ++ " * " ++ n ++ ")"
  App (App (Con (General Divi)) (dd -> m)) (dd -> n)
    -> "(" ++ m ++ " / " ++ n ++ ")"
  App (Con (General EqGen)) (Pair (dd -> m) (dd -> n))
    -> "(" ++ m ++ " ‚âê " ++ n ++ ")"
  App (App (Con (General EqRl)) (dd -> m)) (dd -> n)
    -> "(" ++ m ++ " ‚âê " ++ n ++ ")"
  App (Con (General (Interp n))) (dd -> u) -> "‚ü¶" ++ u ++ "‚üß"
  App (App (Con (General Upd)) (dd -> m)) (dd -> n)
    -> m ++ "‚à∑" ++ n
  App (App (Con (Special GTE)) (dd -> m)) (dd -> n)
    -> "(" ++ m ++ " ‚â• " ++ n ++ ")"
  App (dd -> m) n@(dd -> n') -> m ++ case n of
                                       Lam _ -> n'
                                       Fst _ -> n'
                                       Snd _ -> n'
                                       _ -> "(" ++ n' ++ ")"
  Con (show -> c) -> c
  Lam t' -> case fs of
    fresh:rest -> "(Œª" ++ fresh ++ "." ++ displayVs' rest (\case
                                                              Get -> fresh
                                                              Weaken x -> œÅ x)
                  t' ++ ")"
    _ -> error "displayVs: ran out of fresh variables."
  Fst (dd -> m) -> "(œÄ‚ÇÅ " ++ m ++ ")"
  Snd (dd -> m) -> "(œÄ‚ÇÇ " ++ m ++ ")"
  TT -> "‚ãÑ"
  Pair (dd -> m) (dd -> n) -> "‚ü®" ++ m ++ ", " ++ n ++ "‚ü©"

lft' :: Applicative f => (forall v. v ‚àà Œ≥ -> f (v ‚àà Œ¥)) -> (forall v. v ‚àà (Œ≥ √ó Œ±) -> f (v ‚àà (Œ¥ √ó Œ±)))
lft' _ (Get) = pure Get
lft' f (Weaken x) = Weaken <$> (f x)


lft :: (Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> Œ± ‚àà (Œ≥ √ó Œ≤) -> Œ± ‚àà (Œ¥ √ó Œ≤)
lft f = \case
  Get -> Get
  Weaken i -> Weaken $ f i

œÄ :: Œ± ‚àà Œ∫ -> Œ≥ ‚ä¢ Œ∫ -> Œ≥ ‚ä¢ Œ±
œÄ Get Œ∫ = Snd Œ∫
œÄ (Weaken i) Œ∫ = œÄ i (Fst Œ∫)

type Context0 = Unit √ó ('R ‚ü∂ 'R ‚ü∂ 'T) √ó 'R √ó ('E ‚ü∂ 'T) √ó ('E ‚ü∂ 'R) √ó 'E
type Context1 = Unit √ó
                ('Œì ‚ü∂ 'E) √ó
                ('Œì ‚ü∂ 'E) √ó
                ('E ‚ü∂ 'E ‚ü∂ 'T) √ó
                ('E ‚ü∂ 'E ‚ü∂ 'T) √ó
                ('E ‚ü∂ 'T) √ó 'E √ó 'E
type Context2 = Unit √ó ('Œì ‚ü∂ 'E) √ó ('E ‚ü∂ 'T) √ó 'E √ó 'E

data Nat where
  Zero :: Nat
  Succ :: Nat -> Nat

data Witness (n :: Nat) where
  Z :: Witness 'Zero
  S :: Witness n -> Witness ('Succ n)

type family Context (n :: Nat) where
  Context 'Zero = Context0
  Context ('Succ 'Zero) = Context1
  Context ('Succ ('Succ 'Zero)) = Context2

findC :: Witness n -> Special Œ± -> Œ± ‚àà Context n
findC = \case
  Z -> \case
    Vlad -> Get
    Height -> Weaken Get
    Human -> Weaken (Weaken Get)
    Theta -> Weaken (Weaken (Weaken Get))
    GTE -> Weaken (Weaken (Weaken (Weaken (Get))))
  S Z -> \case
    Entity 0 -> Get
    Entity 1 -> Weaken Get
    Property 0 -> Weaken (Weaken Get)
    Relation 0 -> Weaken (Weaken (Weaken Get))
    Relation 1 -> Weaken (Weaken (Weaken (Weaken Get)))
    Sel 0 -> Weaken (Weaken (Weaken (Weaken (Weaken Get))))
    Sel 1 -> Weaken (Weaken (Weaken (Weaken (Weaken (Weaken Get)))))
  S (S Z) -> \case
    Entity 0 -> Get
    Entity 1 -> Weaken Get
    Property 0 -> Weaken (Weaken Get)
    Sel 0 -> Weaken (Weaken (Weaken Get))
           
rename :: (‚àÄŒ±. Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> Œ≥ ‚ä¢ Œ≤ -> Œ¥ ‚ä¢ Œ≤
rename f = \case
  Var i -> Var $ f i
  Con c -> Con c
  App (rename f -> m) (rename f -> n) -> App m n
  Lam (rename (lft f) -> m) -> Lam m
  Fst (rename f -> m) -> Fst m
  Snd (rename f -> m) -> Snd m
  TT -> TT
  Pair (rename f -> m) (rename f -> n) -> Pair m n

renameNeu :: (forall Œ±. Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> Neutral Œ≥ Œ≤ -> Neutral Œ¥ Œ≤
renameNeu f = \case
  NeuVar i -> NeuVar $ f i
  NeuCon c -> NeuCon c
  NeuApp (renameNeu f -> m) (renameNF f -> n) -> NeuApp m n
  NeuFst (renameNeu f -> m) -> NeuFst m
  NeuSnd (renameNeu f -> m) -> NeuSnd m
  NeuTT -> NeuTT

renameNF :: (forall Œ±. Œ± ‚àà Œ≥ -> Œ± ‚àà Œ¥) -> NF Œ≥ Œ≤ -> NF Œ¥ Œ≤
renameNF f = \case
  (Neu (renameNeu f -> m)) -> Neu m
  (NFLam (renameNF (lft f) -> m)) -> NFLam m
  (NFPair (renameNF f -> m) (renameNF f -> n)) -> NFPair m n

wkn :: Œ≥ ‚ä¢ Œ± -> (Œ≥ √ó Œ≤) ‚ä¢ Œ±
wkn = rename Weaken

exch :: ((Œ≥ √ó Œ±) √ó Œ≤) ‚ä¢ œâ -> ((Œ≥ √ó Œ≤) √ó Œ±) ‚ä¢ œâ
exch = rename $ \case
  Get -> Weaken Get
  Weaken Get -> Get
  Weaken (Weaken i) -> Weaken (Weaken i)

contr :: (Œ≥ √ó Œ± √ó Œ±) ‚ä¢ Œ≤ -> (Œ≥ √ó Œ±) ‚ä¢ Œ≤
contr = rename $ \case
  Get -> Get
  Weaken i -> i

hmorph0 :: Witness n -> Œ≥ ‚ä¢ Œ± -> (Œ≥ √ó Context n) ‚ä¢ Œ±
hmorph0 n = \case
  Var i -> Var $ Weaken i
  Con (Special c) -> œÄ (findC n c) (Var Get)
  Con c -> Con c
  App (hmorph0 n -> m) (hmorph0 n -> n) -> App m n
  Lam (hmorph0 n -> m) -> Lam $ exch m
  Fst (hmorph0 n -> m) -> Fst m
  Snd (hmorph0 n -> m) -> Snd m
  Pair (hmorph0 n -> m) (hmorph0 n -> n) -> Pair m n
  TT -> TT

hmorph :: Witness n -> Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ (Context n ‚ü∂ Œ±)
hmorph n (hmorph0 n -> m) = Lam m

Œ∑ :: Œ≥ ‚ä¢ Œ± -> Œ≥ ‚ä¢ ((Œ± ‚ü∂ 'R) ‚ü∂ 'R)
Œ∑ m = Lam (App (Var Get) (wkn m))

(‚ãÜ) :: Œ≥ ‚ä¢ ((Œ± ‚ü∂ 'R) ‚ü∂ 'R) -> Œ≥ ‚ä¢ (Œ± ‚ü∂ ((Œ≤ ‚ü∂ 'R) ‚ü∂ 'R)) -> Œ≥ ‚ä¢ ((Œ≤ ‚ü∂ 'R) ‚ü∂ 'R)
m ‚ãÜ k = Lam (App (wkn m) (Lam (App (App (wkn (wkn k)) (Var Get)) (Var (Weaken Get)))))

(>>) :: Œ≥ ‚ä¢ ((Unit ‚ü∂ 'R) ‚ü∂ 'R) -> Œ≥ ‚ä¢ ((Œ≤ ‚ü∂ 'R) ‚ü∂ 'R) -> Œ≥ ‚ä¢ ((Œ≤ ‚ü∂ 'R) ‚ü∂ 'R)
m >> k = m ‚ãÜ Lam (wkn k)
